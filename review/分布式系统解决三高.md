1. 高性能  
   1. 数据存储 
      1. 读写分离  
      2. 分库/分表  
         1. 水平拆分(数据量做拆分)
         2. 垂直拆分(冷热数据拆分)   
   2. 数据缓存 
      1. 缓存穿透:用户频繁访问数据库中没有的数据，导致大量请求到数据库层,数据库负载增加；  
            - 加锁排队
              - 实现原理
                - 查询数据库执行加锁操作，控制并发数。
            - 布隆过滤器
                - 实现原理  
                  - 通过K个哈希函数计算该数据,返回K个计算出的hash结果
                  - 这些K个哈希值映射到对应K个二进制的数组下标
                  - 将K个二进制数组下标变为1
      2. 缓存雪崩:缓存中批量热点数据失效，导致大量请求到数据库，负载增加； 
        - 加锁控制
            - 查询数据库执行加锁操作，控制并发数
        - 缓存预加载机制
            - 定时访问数据库来更新缓存
        - 添加随机失效时间
            - key不仅有定期失效时间，也需要添加随机失效时间，保证同一批key失效时间不同而避免雪崩
      3. 缓存击穿:缓存中单个热点数据失效，导致大量请求到数据库，负载增加；   
        - 后台定时刷新
            - 后台设置定时任务刷新缓存
        - 主动检测更新
            - 业务从数据库获取数据写入缓存时，将缓存失效时间一起写入，每次从缓存获取数据后先比对缓存失效时间和当前时间，他们时间差小于某一阈值时，考虑从数据库重新拉去数据更新缓存
        - 设置多层缓存
            - 
   3. 如何保证缓存和数据库数据一致  
        - 懒加载：查询数据库时发现缓存不存在，主动到数据库进行查询并加载到缓存;
            - 写操作，在更新数据库之前删除缓存; (读写并发时导致向缓存中更新脏数据&第二步失败);(前置删除)
            - 写操作，在更新数据库之后删除缓存;(同样读写并发导致向缓存中更新脏数据&第二步失败);(后置删除，较推荐)
            - 写操作，在更新数据库前后都进行缓存删除;(读写并发时导致向缓存中更新脏数据);(双删)
            - 写操作，业务更新数据库前删除缓存，写入数据库时也往消息队列中写一份，消息队列消费写入key去删除缓存;（异步重试,与业务耦合）
            - 写操作，业务更新数据库前删除缓存，更新数据库后通过消息队列订阅数据库变更binlog删除缓存(删除失败会一致重试),与业务解耦;(双删+消息队列订阅binlog删除缓存)
        - 主动加载: 数据库更新后同步或者异步进行缓存更新;
          - 写操作流程  
            1. 先删除缓存的键;
            2. 更新数据库；
            3. 监听数据库binlog，解析出数据键；
            4. 将数据键写入消息队列；
            5. 消息队列根据数据键读取数据库获取相应数据并刷新到缓存;
          - 读操作流程
            1. 先读缓存;
            2. 没有缓存，读数据库;
            3. 异步将数据键写入消息队列(与写操作一个消息队列);
            4. 消息队列根据数据键读取数据库获取相应数据并刷新到缓存;  
2. 高可用
   1. 数据存储
      1. 主备模式:主可读可写，从只负责同步主数据；主出现问题是，人工切换成从。
      2. 主从模式:主写从读,从负责同步主数据；主出现问题时，人工切换从。
         -  如何解决主发生故障时，人工切换主从(备)呢？
            1. 主从双方互相进行心跳检测,可能因为网络分区问题导致"脑裂"(变成两个主):主从两个节点网络断开,互相发现没有心跳导致两个都变为主。
            2. 引入第三方检测主从是否心跳正常，可以避免"脑裂"
      3. 双主模式:都可读写且相互同步，可能存在数据回环复制的问题。
         - 什么是数据回环复制？如何解决数据回环复制?
           - 数据回环复制:A主和B主分别接受写指令,并将写指令给对方进行同步;A获取B的的写指令,A又将B的写指令再次同步给B,这样就形成了一个回环复制。
           - 解决回环:写入命令增加oplog参数,oplog中有shardId(不同redis实例有不用的shardId),A获取B的写指令时，发现是B从过来的，就不会再给B进行同步。

