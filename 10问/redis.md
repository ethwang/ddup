1. redis的数据结构有哪些？
2. redis有序集合使用跳表的不用红黑树的原因
3. mysql使用b+树不用跳表的原因
4. redis使用跳表不用b+树的原因
5. redis持久化
6. redis主从复制
7. redis哨兵模式
8. redis集群模式
9. redis分布式锁实现原理
10. redis在缓存的场景？如何保证一致性?



#### 是什么？为什么？如何实现的？
1. redis的数据结构有哪些？
   1. 简单动态字符串-字节数组
     - 定义：封装了一个结构体包括字符数组，已使用长度，未使用的长度
     - 优点：
       - 常数复杂度获取字符串长度
       - 杜绝缓冲区溢出
       - 减少修改字符串长度时所需的内存重分配次数
       - 二进制安全
       - 兼容c字符串函数
    - 使用：
      - 键和字符串值
      - aof缓冲区
      - 客户端输入缓冲区
   2. 链表-双向链表
    - 定义：
      - 双向
      - 无环
      - 带表头指针和表尾指针
      - 带链表长度计数器
    - 使用
      - 列表键
   3. 字典-哈希表
     - 定义
       - 每个字典有两个哈希表，一个平时使用，另一个仅在进行rehash时使用
       - 链地址法解决键冲突
       - 哈希表扩容或收缩时，将现有哈希表包含的键值对rehash到新哈希表中(不是一次性完成，渐进式完成)
     - 使用
       - 哈希键
       - 数据库
   4. 跳表
      - 跳表是有序集合的底层实现之一
      - redis的跳表实现由zskiplist和zskiplistNode两个结构组成,其中zskiplist用于保存跳表的信息(例如表头指针，表尾指针，长度),而zskiplistNode用于表示跳表结点。
      - 每个跳表结点的层高是1-32的随机数。
      - 同一个跳表中，多个结点可以含有相同的分值，但是每个节点的成员对象必须唯一的
      - 跳表中的节点按照分值大小排序，当分值相同时，节点按照成员对象的大小进行排序
   5. 整数集合-整数数组
      - 整数集合是集合键的底层实现之一
      - 整数集合的底层实现时数组，这个数组以有序无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素类型，改变这个数组类型
      - 升级操作为整数集合带来了操作上的灵活性，并尽可能节约内存
      - 整数集合只支持升级操作，不支持降级操作
   6. 压缩列表
      - 压缩列表是一种为节约内存而设计的顺序型数据结构
      - 压缩列表被用作列表键和哈希键的底层实现之一
      - 压缩列表可以包含多个节点，每个节点都可以保存一个字节数组或者整数值
      - 添加新节点到压缩列表或者从压缩列表中删除节点，可能引发连锁更新操作

2. redis有序集合使用跳表的不用红黑树的原因 
   - 答:
    - 跳表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。
    - 范围查找：跳表比平衡树效率高。在平衡树上，我们找指定范围的小值后，还需要以中序遍历的顺序继续寻找其他不超过大值的节点。而在跳表中进行范围查找就比较简单，只需要在找到小值之后，对第一层链表进行若干步遍历就可以实现。
    - 实现简单：平衡树插入和删除引发子树的调整，逻辑复杂。跳表的插入和删除只需要修改相邻节点的指针。
    - 内存占用：跳表每个节点的指针数量比平衡树更加灵活。平衡树每个节点有两个指针，而跳表每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像redis里实现的一样p=1/4,平均每个节点指针数量比平衡树要少，所以内存占用也更少。
   - 参考
      - [随机层数产生细节](https://www.cyningsun.com/06-18-2018/skiplist.html)
      - [redis使用跳表不用红黑树](https://juejin.cn/post/6844903446475177998)
3. mysql使用b+树不用跳表的原因(比较b+树和跳表)
   - 答:
    - B+树是多叉平衡树，每个节点都是一个16k的数据页，能存放较多的索引信息，所有扇出很高。三层左右可以存储2kw左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询三次磁盘。
    - 跳表是链表结构，一条数据一个节点，如果最底层存放2kw数据，且每次查询都要达到二分查找的效果，2kw大概2的24次方左右，所以跳表高度在24层左右。最坏情况下，24层数据分散在不同的数据页里，查一次数据需要经历24次磁盘IO。
    - 因此存放同样量级的数据，B+树高度要比跳表少。如果放在mysq数据库上，高度少磁盘io就少查询效率就高。
    - 但是，对于写操作，B+树需要合并拆分索引数据页；跳表则独立插入并随机确定层数，没有旋转维持平衡的开销，因此跳表写入性能比b+树好。
4. redis使用跳表不用b+树
   - 答:
      - 读取性能:redis是内存数据库，数据读写都在内存操作与磁盘io无关，所以层高也不是跳表查询的瓶颈。
      - 写入性能:跳表插入操作(redis使用跳表写入性能更高)简单高效，少了平衡树旋转平衡的开销。
   - 参考
     - [MySQL的索引为什么使用B+树而不使用跳表](https://www.51cto.com/article/706701.html)

5. redis持久化
    - redis是内存数据库，一旦服务器进程退出，redis中的数据会丢失，所以需要定期将redis数据持久化到磁盘。当redis服务重启时可以加载磁盘中的持久化数据，保证和退出前状态一致。redis有两种持久化的方式:
    - RDB持久化:对redis数据持久化,全量备份
        - rdb实现方式
          - SAVE:生成rdb文件时主进程(执行客户端读写命令)被阻塞,直到rdb文件创建成功后才会解除阻塞
          - BGSAVE:创建子进程生成当前时间点的rdb文件,父进程继续执行客户端读写命令
            - 写时复制机制会使fork子进程开销不大:创建子进程时，父子进程共享同一个物理内存，(?和不同的虚拟内存);当父进程(redis服务端)执行写命令时,子进程会复制当前父进程的物理内存,开辟新的物理内存空间,所以子进程拷贝的数据是写时复制那一刻的数据，后续父进程的写入命令不会被拷贝.
        - rdb文件载入:redis服务器启动时自动载入
        - 自动间隔性保存:
          - saveparams数组：设置多个保存条件
          - dirty:记录距离上次成功执行bgsave命令后，对数据库状态(写入，删除和更新)的修改次数
          - lastsave:记录上一次成功执行bgsave的时间
          - 根据dirty和lastsave去saveparams数组中查找符合的条件，如果有则进行bgsave
        - rdb文件结构
    - AOF持久化:对redis写命令持久化,增量备份
        - aof实现方式
          - 命令追加：服务器执行完一个写命令后，将该命令追加到服务器的aof_buf缓存区的末尾
          - aof文件写入和同步磁盘(3种方式):调用flushAppendOnlyFile函数考虑是否需要将aof_buf缓冲区的内容写入和保存到aof文件中
            - 写入：当调用操作系统write函数将一些数据写入到文件时，操作系统会将写入数据暂时保存在一个内存缓冲区中，等到缓冲区空间被填满或超过了时限才真正将缓冲区中的数据写入到磁盘里面
            - 同步:将内存缓存区的内容写入磁盘
            - flushAppendOnlyfile函数的三种行为
              - 将aof_buf缓存区的内容写入并同步到aof文件(安全但效率低)
              - 将aof_buf缓存区内容先写入aof文件；如果上次同步aof的时间距离现在超过1s,那么再次对aof文件同步(由一个线程执行的)(比较安全，效率比较高)
              - 将aof_buf缓存区内容写入aof文件，但不做同步操作，何时同步等待操作系统决定(效率高但不安全)
        - aof文件载入和数据还原:伪客户端从aof文件中读取并执行写命令
        - aof重写:原aof文件体积过大使用aof文件进行数据还原的时间过长,所以重写功能是创建一个新的aof文件替代现有的aof文件，新旧aof文件保存的状态一致，但新aof文件体积比之前的小(不含冗余指令)
          - aof重写是通过读取数据库当前状态实现的(从数据库读取键现在的值，然后用一条命令去记录键值对代替之前记录这个键值对的多条指令)，而不是分析原有的aof文件
        - aof后台重写(子进程重写),与rdb后台执行类似
          - aof重写缓存区:从创建子进程开始，redis服务器执行完一个写命令后，会同时将这个写命令发送给aof缓冲区和aof重写缓冲区;
            - aof缓存区的内容会定期被写入和同步到aof文件
            - 从创建子进程开始，服务器执行的所有写命令都会被记录到aof重写缓冲区中
          - 子进程aof重写工作完成后会向父进程发送一个信号，父进程接受信号后会调用信号处理函数
            1. 将aof重写缓冲区的内容写入到新的aof文件中
            2. 对新的aof文件进行改名原子的覆盖现有aof文件
          - 整个aof后台重写过程中只有信号处理函数执行时会对服务器进程造成阻塞

6. redis主从复制
    - 为了提供可用性，redis通过主从复制来做数据冗余。
    - 旧版复制原理
        - 同步:将从服务器的数据库状态更新至主服务器当前所处的数据库状态; 
            - 过程:
               1. 从服务器向主服务器发送sync;
               2. 主服务器收到sync命令后,执行BGSAVE命令,在后台生成一个rdb文件,并使用一个缓存区记录从现在开始执行的所有写命令；
               3. 主服务器将rdb文件发送给从服务器,从服务器载入rdb文件;
               4. 主服务器将记录的缓存区里面的所有写命令发送给从服务器，从服务器执行这些写命令;     
        - 命令传播:主服务器的数据库状态被修改，导致主从服务器状态不一致，让主从服务器重新回到一致的状态;
        - 缺点:命令传播阶段,主从服务器断开并重新链接后，从服务器会重新发送sync命令给主服务器，主从服务器会走一个完整的同步流程，会重复复制从服务器已有的数据，导致低效。 
    - 新版复制原理
        - 新版复制使用psync代替sync命令,psync有完整重同步和部分重同步两种模式；完整重同步用于处理初次复制情况，部分重同步用于处理命令传播阶段主从断线后重复制的情况(主只会复制链接断线后的写命令给从)。
        - 实现部分重同步的三个部分
          - 主服务器的复制偏移量(主从各维护一个复制偏移量,从向主发送psync会带上复制偏移量，便于主判断执行完整重同步还是部分重同步;如果主的复制积压缓存中有从偏移量+1的数据则执行部分重同步，否则执行完整重同步)
          - 主服务器的复制积压缓存(主进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓存区里面。积压缓存区中的每个字节会记录相应的偏移量)
          - 服务器的运行ID(从向主发送psync会带上主的运行id,便于主判断是进行完整重同步还是部分重同步)
        - 心跳检测
            - 命令传播阶段，从会以每秒一次的频率向主发送当前的复制偏移量。比较重要的作用是检测命令丢失，如果因为网络原因主向从传播的命令从没有收到，从给主发送心跳检测时，主发现从的复制偏移量和自己的不一致，主在复制缓存区查找从偏移量+1的数据发送给从，保证主从数据一致。

7. redis哨兵模式 
    - 是redis一种高可用的解决方案:由一个或多个哨兵实例组成的系统监视多个主服务器及这些主服务器下的所有从服务器;如果被监视的主服务器处于下线状态时，自动将下线的主服务器下的某个从服务器升级为新的主服务器，由新的主服务器处理命令。
    - 初始化哨兵
      - 每个哨兵节点是一个运行在特殊模式下的redis服务器
      - 初始化实例结构，会保存所有被监视的主从redis实例状态
      - 创建连向主服务器的网络链接。命令链接：向主服务器发送命令，并接受命令回复。订阅链接：订阅主服务器某个频道。
    - 获取主从服务器信息
      - 哨兵会以每十秒一次的频率通过命令链接向被监视的主服务器发送INFO命令并通过分析INFO命令回复获取主服务器和从服务器当前信息并更新相应的实例结构。同时,创建链接到从服务器的命令链接和订阅链接。
    - 接收来自主从服务器的频道信息
      - 对于每个与哨兵链接的服务器，哨兵既通过命令链接向服务器频道发送信息，又通过订阅链接从服务器频道接受信息
      - 监视同一个服务器的多个哨兵，一个哨兵发送的信息会被其他哨兵接收到，通过这种方式发现其他哨兵并为其建立实例结构和相互间建立命令链接
    - 检测主观下线
      - 哨兵会以每秒一次的频率向所有与他建立命令链接的实例发送ping命令，并通过实例返回的ping命令回复来判断实例是否在线(哨兵在规定时间内连续收到主服务器回复的无效命令时，判断主观下线)
    - 检测客观下线
      - 当哨兵将一个主服务器判断为主观下线后，会向同样监视这一主服务器的其他哨兵询问，当从其他哨兵那里接受到足够数量的已下线的判断后，当前哨兵将该主服务器判定为客观下线。 
    - 选举领头哨兵
      - 每个发现主服务器进入客观下线的哨兵都会要求其他哨兵将自己设置为领头哨兵,如果有半数以上的哨兵将自己设置为领头哨兵则该哨兵成为领头哨兵
    - 故障转移
        - 在已下线主服务器下的所有从服务器里面，挑选一个从服务器，并将其转换为主服务器(slaveof no one)。怎么挑选新的主服务器？
          - 哨兵会将已下线的主服务的所有从服务器保存在一个列表中
          - 删除列表中处于下线或断线的从服务器
          - 删除最近五秒内没有回复过领头哨兵INFO命令的从服务器
          - 删除所有与已下线主服务器断开超过一定时间的从服务器，保证从服务的数据比较新
          - 如果有多个满足条件的从服务器，选复制偏移量大的从服务器
        - 让已下线的主服务器属下的所有从服务器改为复制新的主服务器(slaveof new_server_ip new_server_port)
        - 将已下线主服务器设置为新的主服务的从服务器(slaveof new_server_ip new_server_port)

8. redis集群模式(数据分片存储+多副本模式)
    - 节点(多个节点相互链接组成了redis集群)
        - 初始化数据结构
          - clusterState:每个节点持有该结构，记录当前节点视角下集群的状态(上线/离线，集群其他节点)
          - clusterNode:记录当前节点的状态，并为其他节点创建相应的结构记录其他节点状态
          - clusterLink:记录连接节点所需的信息(套接字描述符,输入/输出缓存区,被链接节点的信息)
        - 节点间的连接(通过cluster meet)
          - 两个节点间握手(三次握手,meet,pong,ping)
          - 与多个节点握手
    - 槽指派(数据库中的每个键都属于这16384个槽的其中一个,当16384个槽位都有节点在处理时，集群处于上线状态，通过addslots命令将槽指派给节点(更新槽位数据结构))
        - 记录本节点的槽指派信息(clusterNode)
          - 二进制位数组(16384/8=2048字节,数组索引i上值为1该节点负责处理i槽)
          - 整型变量(处理槽的数量)
        - 向集群中其他节点传播自己的槽指派信息(其他节点会更新收到的槽指派信息到相应节点的clusterNode中)
        - 记录集群所有槽的指派信息(clusterState)
          - slots数组，含16384个项，每个项都指向clusterNode结构(slots[i]指向是否为空表示i槽是否被分配出去并被分配的哪个节点)
    - 在集群中执行命令
        - 计算键属于哪个槽 
        - 判断槽是否属于当前节点,如果不是则返回moved错误,客户端会根据moved返回的ip,port转向其他节点操作。集群模式会自动进行节点转向，单机模式会打印moved错误
        - 保存槽和键的关系(clusterState中的一个跳表结构保存槽和键的关系)
            - 跳表每个节点的分值是槽号,每个节点成员时数据键(一个槽对应多个键),方便的对某个槽的所有数据库键进行批量操作
    - 重新分片(将任意数量已经指派给某个节点的槽改为指派给另一个节点,并且相关槽所属的键值对也会从源节点被移动到目标节点。重新分片的过程中集群不需要下线并且源节点和目标节点都可继续处理命令请求)
        - 原理(集群管理软件redis-trib通过向源节点和目标节点发送命令来进行重新分片,对单个槽进行重新分片)
          - redis-trib会向源节点发送获取键命令，获取一定数量属于该槽的键值对的键名
          - 获取到键名后，继续向源节点发送键迁移命令，把选中的键原子的从源节点迁移至目标节点 
          - 重复执行上面两步直到该槽位的键全部迁移完成
          - redis-trib向任意节点发送槽指派信息，这个指派信息会通过消息发送至整个集群
          - 如果涉及到多个槽重新指派，redis-trib会对每个槽执行上面的步骤
        - ask错误(重新分片期间:被迁移槽的一部分数据在源节点另一部分在目标节点)
            - 在迁移之前，redis-trib会分别对源节点和目标节点发送migrating和importing命令，源节点和目标节点执行后会建立一个迁移的数据结构来标识该槽正在迁移并关联迁移的节点
            - 当有用户来请求迁移槽中的键时，节点会先从自己的数据库中查找；如果没有找到，则会检查迁移的数据结构关联的节点，向用户发送ask错误引导客户端去该节点查询
        - asking命令的作用
            - 当客户端在源节点查不到迁移槽的键时，会根据ask错误转向目的节点去查迁移槽中的键，但此时目标节点发现该槽不属于自己，就会直接返回moved错误又指向源节点，造成死锁
            - 所以客户端在源节点找不到迁移槽的键而转向目标节点请求时，会先向目标节点发送asking命令再发送执行命令，目标节点收到asking命令，会去迁移数据结构中查找该槽是否被迁移，如果被迁移则执行该键的操作
        - ask错误和moved错误的区别
          - ask错误是两个节点在迁移槽的过程中使用的临时措施
          - moved错误表示槽的负责权已经从一个节点转移到另一个节点

    - 复制与故障迁移
        - 为主节点设置从节点,从节点会复制主节点的数据。主节点下线时，集群中其他主节点会选出下线主节点下面的一个从节点作为新的主节点接管原来节点负责的槽位
        - 故障检测
          - 每个节点定期向集群中的其他节点发送ping信息，如果接受到ping信息的节点没有在规定时间内回复。那么发送ping信息的节点就认为该节点疑似下线
          - 集群中各个节点通过互相发送消息的方式交换集群中各个节点的状态信息(在线，疑似下线，下线)
          - 如果一个集群里面半数以上主节点都将主节点a设置为疑似下线，那么该节点将主节点a标记为已下线并向集群广播，收到广播的节点将节点a标记为下线
        - 故障转移
          - 当一个从节点发现自己复制的主节点下线时，该从节点将开始对下线的主节点进行故障转移
          - 下线主节点的所有从节点会有一个从节点被选中
          - 被选中的从节点会执行slaveof no one成为新的主节点
          - 新主节点会将旧主的槽指派给自己(主从复制不会复制槽指派信息，只有在故障转移时从节点才会将主节点的槽指派给自己)
          - 新主会向集群中广播，让其他节点知道自己变为主节点并负责相关的槽位
        - 在从节点中选举新主(raft算法领头选举)
          - 某个节点故障转移时，集群配置纪元会增一 
          - 每个配置纪元集群中的主节点都有一次投票机会，第一个向主节点要求投票的从节点会获得主节点的投票
          - 当从节点发现自己复制的主节点进入已下线的状态时，从节点会向集群广播消息，要求所有收到消息的主节点向该从节点投票
          - 如果一个主节点有投票权并未投票将向从节点回复信息支持
          - 每个参与选举的从节点统计收到的回复支持的数量，如果大于等于N/2+1，这个从节点当选为主节点
          - 如果所有参与选举的从节点都没有足够的票数会进入新的配置纪元并再次选举

9. redis分布式锁实现原理(分布式锁是控制分布式系统不同进程共同访问共享资源的一种锁的实现。同一个时刻只能有一个进程修改共享资源)
  - 定义
    - 分布式锁是控制分布式系统不同进程共同访问共享资源的一种锁的实现。同一个时刻只能有一个进程修改共享资源。
  - 基本原理
    - 分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存(redis,memcache)，保证标记互斥。
  - 分布式锁的特性
    - 互斥性:任意时刻只有一个进程获取到锁
    - 锁超时释放:持有锁超时可以释放防止死锁
    - 可重入性:一个线程获取了锁之后可以再次对其请求加锁
    - 高可用，高性能:加锁或者解锁开销尽可能小
    - 安全性:锁只能被持有的进程删除，不能被其他进程删除
  - 方案(redis分布式锁方案)
    - setnx+expire(setnx key value,如果key不存在返回1，存在返回0)
      - 问题：setnx和expire不是原子操作，如果执行完setnx加锁，执行expire失败及后续释放锁失败(进程退出)会导致锁无法被释放
    - setnx+value(系统时间+过期时间):过期时间放入value
      - 问题：锁被其他进程释放
    - 使用lua脚本(setnx+expire):原子性的执行setnx和expire两条指令
      - 问题 
    - set扩展命令(set ex px nx):原子性的设置setnx和expire两条指令
      - 锁过期释放了业务还没执行完
      - 锁被其他进程误删
    - set扩展命令(set ex px nx)+校验唯一的随机值,再释放锁
      - 针对上面问题优化在value增加当前进程的唯一标识，在释放时原子的比对标识和进行删除
    - 开源框架redisson
    - redlock
    - [七种分布式锁](https://juejin.cn/post/6936956908007850014)

10. redis做为缓存的场景？如何保证与存储的数据一致?
  - 适合&不适合缓存场景
    - 读多写少的场景下适合做缓存
    - 写多读少不适合缓存，考虑将数据库分库分表来增加写入性能 
    - 数据一致性要求高不适合缓存
  - 如何保证与数据库数据一致
    - 懒加载:当查询数据的时候发现缓存不存在,主动到数据库中进行查询并加载到缓存，而当数据执行更新或者添加时只是删除缓存，不做缓存加载的操作。
      - 数据库更新前缓存删除
        - 问题：在缓存删除之后和数据库更新之前有请求来获取数据会导致将旧数据更新到缓存
      - 数据库更新后缓存删除
        - 问题：数据库更新之后缓存删除失败导致缓存依旧是旧数据
      - 前后缓存双删,数据库更新之前删除缓存一次，数据库更新之后再删除缓存一次;读:先读缓存，没有；读数据库再更新缓存
        - 问题
          -  有请求在删除缓存之后更新数据库之前拿到旧数据，此时数据库更新之后删除缓存，这时读取请求将旧数据更新到缓存,此时缓存是旧数据
        - 解法
          - 加入消息队列延迟第二次删除的时机(无法彻底解决脏数据问题，只是降低了脏数据的写入概率)
            1. 先删除缓存
            2. 再写数据库
            3. 删除缓存操作异步写入消息队列
            4. 消息队列消费，再次删除缓存
          - 设置缓存失效时间(保证最终一致性的方案):缓存过期,后续读请求会从数据库中获取新值回填缓存,但在超时时间内数据存在不一致。
          - 基于数据库binlog解析后实现缓存删除方案
            1. 更新数据库之前先删除缓存
            2. 更新数据库
            3. 数据库将操作信息写入binlog日志中，通过binlog日志解析(针对数据库写操作进行同步)并同步写入消息队列
            4. 消息队列消费binlog日志数据(针对写操作)重试删除缓存操作直到成功
    - 主动加载:在数据库更新后同步或者异步进行缓存更新
      - 并行读写操作,缓存会出现脏数据
        - 写操作流程:第一步先删除缓存，删除之后再更新数据库，之后再异步将数据刷回缓存
        - 读操作流程:第一步先读取缓存，如果缓存没有读取到，则读取数据库之后再异步刷回缓存
      - 串行读写操作
        - 
    - [缓存一致性常见方案](https://www.jianshu.com/p/1a14fcc22204)
