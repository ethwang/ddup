1. redis的数据结构有哪些？
2. redis有序集合使用跳表的不用红黑树的原因
3. mysql使用b+树不用跳表的原因
4. redis使用跳表不用b+树的原因
5. redis持久化
6. redis主从复制
7. redis哨兵模式
8. redis集群模式
9. redis分布式锁实现原理
10. redis在缓存的场景？如何保证一致性?



#### 是什么？为什么？如何实现的？
1. redis的数据结构有哪些？
   1. 简单动态字符串-字节数组
     - 定义：封装了一个结构体包括字符数组，已使用长度，未使用的长度
     - 优点：
       - 常数复杂度获取字符串长度
       - 杜绝缓冲区溢出
       - 减少修改字符串长度时所需的内存重分配次数
       - 二进制安全
       - 兼容c字符串函数
    - 使用：
      - 键和字符串值
      - aof缓冲区
      - 客户端输入缓冲区
   2. 链表-双向链表
    - 定义：
      - 双向
      - 无环
      - 带表头指针和表尾指针
      - 带链表长度计数器
    - 使用
      - 列表键
   3. 字典-哈希表
     - 定义
       - 每个字典有两个哈希表，一个平时使用，另一个仅在进行rehash时使用
       - 链地址法解决键冲突
       - 哈希表扩容或收缩时，将现有哈希表包含的键值对rehash到新哈希表中(不是一次性完成，渐进式完成)
     - 使用
       - 哈希键
       - 数据库
   4. 跳表
      - 跳表是有序集合的底层实现之一
      - redis的跳表实现由zskiplist和zskiplistNode两个结构组成,其中zskiplist用于保存跳表的信息(例如表头指针，表尾指针，长度),而zskiplistNode用于表示跳表结点。
      - 每个跳表结点的层高是1-32的随机数。
      - 同一个跳表中，多个结点可以含有相同的分值，但是每个节点的成员对象必须唯一的
      - 跳表中的节点按照分值大小排序，当分值相同时，节点按照成员对象的大小进行排序
   5. 整数集合-整数数组
      - 整数集合是集合键的底层实现之一
      - 整数集合的底层实现时数组，这个数组以有序无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素类型，改变这个数组类型
      - 升级操作为整数集合带来了操作上的灵活性，并尽可能节约内存
      - 整数集合只支持升级操作，不支持降级操作
   6. 压缩列表
      - 压缩列表是一种为节约内存而设计的顺序型数据结构
      - 压缩列表被用作列表键和哈希键的底层实现之一
      - 压缩列表可以包含多个节点，每个节点都可以保存一个字节数组或者整数值
      - 添加新节点到压缩列表或者从压缩列表中删除节点，可能引发连锁更新操作

2. redis有序集合使用跳表的不用红黑树的原因 
   - 答:
    - 跳表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。
    - 范围查找：跳表比平衡树效率高。在平衡树上，我们找指定范围的小值后，还需要以中序遍历的顺序继续寻找其他不超过大值的节点。而在跳表中进行范围查找就比较简单，只需要在找到小值之后，对第一层链表进行若干步遍历就可以实现。
    - 实现简单：平衡树插入和删除引发子树的调整，逻辑复杂。跳表的插入和删除只需要修改相邻节点的指针。
    - 内存占用：跳表每个节点的指针数量比平衡树更加灵活。平衡树每个节点有两个指针，而跳表每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像redis里实现的一样p=1/4,平均每个节点指针数量比平衡树要少，所以内存占用也更少。
   - 参考
      - [随机层数产生细节](https://www.cyningsun.com/06-18-2018/skiplist.html)
      - [redis使用跳表不用红黑树](https://juejin.cn/post/6844903446475177998)
3. mysql使用b+树不用跳表的原因(比较b+树和跳表)
   - 答:
    - B+树是多叉平衡树，每个节点都是一个16k的数据页，能存放较多的索引信息，所有扇出很高。三层左右可以存储2kw左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询三次磁盘。
    - 跳表是链表结构，一条数据一个节点，如果最底层存放2kw数据，且每次查询都要达到二分查找的效果，2kw大概2的24次方左右，所以跳表高度在24层左右。最坏情况下，24层数据分散在不同的数据页里，查一次数据需要经历24次磁盘IO。
    - 因此存放同样量级的数据，B+树高度要比跳表少。如果放在mysq数据库上，高度少磁盘io就少查询效率就高。
    - 但是，对于写操作，B+树需要合并拆分索引数据页；跳表则独立插入并随机确定层数，没有旋转维持平衡的开销，因此跳表写入性能比b+树好。
4. redis使用跳表不用b+树
   - 答:
      - 读取性能:redis是内存数据库，数据读写都在内存操作与磁盘io无关，所以层高也不是跳表查询的瓶颈。
      - 写入性能:跳表插入操作(redis使用跳表写入性能更高)简单高效，少了平衡树旋转平衡的开销。
   - 参考
     - [MySQL的索引为什么使用B+树而不使用跳表](https://www.51cto.com/article/706701.html)

5. redis持久化
    - redis是内存数据库，一旦服务器进程退出，redis中的数据会丢失，所以需要定期将redis数据持久化到磁盘。当redis服务重启时可以加载磁盘中的持久化数据，保证和退出前状态一致。redis有两种持久化的方式:
    - RDB持久化:对redis数据持久化
    - AOF持久化:对redis写命令持久化

6. redis主从复制
    - 为了提供可用性，redis通过主从复制来做数据冗余。
    - 旧版复制原理
        - 同步:将从服务器的数据库状态更新至主服务器当前所处的数据库状态; 
            - 过程:
               1. 从服务器向主服务器发送sync;
               2. 主服务器收到sync命令后,执行BGSAVE命令,在后台生成一个rdb文件,并使用一个缓存区记录从现在开始执行的所有写命令；
               3. 主服务器将rdb文件发送给从服务器,从服务器载入rdb文件;
               4. 主服务器将记录的缓存区里面的所有写命令发送给从服务器，从服务器执行这些写命令;     
        - 命令传播:主服务器的数据库状态被修改，导致主从服务器状态不一致，让主从服务器重新回到一致的状态;
        - 缺点:命令传播阶段,主从服务器断开并重新链接后，从服务器会重新发送sync命令给主服务器，主从服务器会走一个完整的同步流程，会重复复制从服务器已有的数据，导致低效。 
    - 新版复制原理
        - 新版复制使用psync代替sync命令,psync有完整重同步和部分重同步两种模式；完整重同步用于处理初次复制情况，部分重同步用于处理命令传播阶段主从断线后重复制的情况(主只会复制链接断线后的写命令给从)。
        - 实现部分重同步的三个部分
          - 主服务器的复制偏移量(主从各维护一个复制偏移量,从向主发送psync会带上复制偏移量，便于主判断执行完整重同步还是部分重同步;如果主的复制积压缓存中有从偏移量+1的数据则执行部分重同步，否则执行完整重同步)
          - 主服务器的复制积压缓存(主进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓存区里面。积压缓存区中的每个字节会记录相应的偏移量)
          - 服务器的运行ID(从向主发送psync会带上主的运行id,便于主判断是进行完整重同步还是部分重同步)
        - 心跳检测
            - 命令传播阶段，从会以每秒一次的频率向主发送当前的复制偏移量。比较重要的作用是检测命令丢失，如果因为网络原因主向从传播的命令从没有收到，从给主发送心跳检测时，主发现从的复制偏移量和自己的不一致，主在复制缓存区查找从偏移量+1的数据发送给从，保证主从数据一致。

7. redis哨兵模式 
    - 是redis一种高可用的解决方案:由一个或多个哨兵实例组成的系统监视多个主服务器及这些主服务器下的所有从服务器;如果被监视的主服务器处于下线状态时，自动将下线的主服务器下的某个从服务器升级为新的主服务器，由新的主服务器处理命令。
    - 初始化哨兵
      - 每个哨兵节点是一个运行在特殊模式下的redis服务器
      - 初始化实例结构，会保存所有被监视的主从redis实例状态
      - 创建连向主服务器的网络链接。命令链接：向主服务器发送命令，并接受命令回复。订阅链接：订阅主服务器某个频道。
    - 获取主从服务器信息
      - 哨兵会以每十秒一次的频率通过命令链接向被监视的主服务器发送INFO命令并通过分析INFO命令回复获取主服务器和从服务器当前信息并更新相应的实例结构。同时,创建链接到从服务器的命令链接和订阅链接。
    - 接收来自主从服务器的频道信息
      - 对于每个与哨兵链接的服务器，哨兵既通过命令链接向服务器频道发送信息，又通过订阅链接从服务器频道接受信息
      - 监视同一个服务器的多个哨兵，一个哨兵发送的信息会被其他哨兵接收到，通过这种方式发现其他哨兵并为其建立实例结构和相互间建立命令链接
    - 检测主观下线
      - 哨兵会以每秒一次的频率向所有与他建立命令链接的实例发送ping命令，并通过实例返回的ping命令回复来判断实例是否在线(哨兵在规定时间内连续收到主服务器回复的无效命令时，判断主观下线)
    - 检测客观下线
      - 当哨兵将一个主服务器判断为主观下线后，会向同样监视这一主服务器的其他哨兵询问，当从其他哨兵那里接受到足够数量的已下线的判断后，当前哨兵将该主服务器判定为客观下线。 
    - 选举领头哨兵
      - 每个发现主服务器进入客观下线的哨兵都会要求其他哨兵将自己设置为领头哨兵,如果有半数以上的哨兵将自己设置为领头哨兵则该哨兵成为领头哨兵
    - 故障转移
        - 在已下线主服务器下的所有从服务器里面，挑选一个从服务器，并将其转换为主服务器(slaveof no one)。怎么挑选新的主服务器？
          - 哨兵会将已下线的主服务的所有从服务器保存在一个列表中
          - 删除列表中处于下线或断线的从服务器
          - 删除最近五秒内没有回复过领头哨兵INFO命令的从服务器
          - 删除所有与已下线主服务器断开超过一定时间的从服务器，保证从服务的数据比较新
          - 如果有多个满足条件的从服务器，选复制偏移量大的从服务器
        - 让已下线的主服务器属下的所有从服务器改为复制新的主服务器(slaveof new_server_ip new_server_port)
        - 将已下线主服务器设置为新的主服务的从服务器(slaveof new_server_ip new_server_port)

8. redis集群模式
