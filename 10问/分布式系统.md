1. 缓存穿透，击穿，雪崩的解决方案;
2. 如何保证缓存与数据库的一致性;
3. 分布式CAP理论;
4. 分布式系统保证数据一致性;(强一致性和最终一致性)
   - raft算法
5. 数据缓存层和数据存储层如何做到高可用和高性能；
   - 数据缓存层高性能
   - 数据存储层高性能
   - 数据存储层高可用
6. 分布式系统是如何进行通信的；
7. 数据库分库分表的场景和原理




## 分布式系统理论和问题
1. 分布式系统CAP理论
   C:一致性，所有节点在同一时间的数据完全一致(多个数据拷贝下并发读写场景);数据更新如何分布到整个系统保证数据一致性
   A:可用性，服务可以正常响应客户的读写操作
   P:分区容错性，分布式系统遇到某个节点和网络分区故障时，仍可以对外提供满足一致性或可用性的需求
2. 分布式系统的一致性(分布式系统提高系统可用性通常使用多副本进行容错，多副本间如何保证一致性)
   - raft算法
      - 选主(leader,follower,candidate)
         - 什么是选主
         - 为什们要选主
            - 分布式系统需要对一个提案做出决策，选出一个主节点去做决策这样的算法更加简单高效。
         - 选主的过程
           - 节点角色
             - leader:请求处理者
             - follower:请求的被动更新者 
             - candidate:中间状态,候选人。follower在一定时间内没有收到leader的心跳，会将状态转成candidate启动选举
           - 任期:每开始一次新的选举，称为一个任期，每个任期都有一个严格递增的整数与之关联
           - 节点角色切换
            - follower角色转换过程
               - raft选主基于一种心跳机制，集群中每个节点刚启动时都是follower身份，leader会周期性的向所有节点发送心跳信息来维持自己的权威。刚开始，每个follower有一个随机定时器，“超时时间”在一定范围内随机生成，最先超时的follower会把角色切换成candidate，增加自己的term号，向集群其他节点发送requestvote rpc，请求其他节点给自己投票。
            - candidate角色转换过程
               - 1. 选举成功
                 - 当candidate从整个集群大多数节点（n/2+1）获得了针对同一term的选票时，就赢得了选举，变成了leader并开始向其他节点发送心跳维持自己的权威(每个节点每个任期只能投出一张选票并且按照先到先得原则确保只有一个candidate称为leader)
               - 2. 选举失败
                  - candidate在等待投票回复时，可能会收到其他自称leader的心跳包，如果这个心跳包里携带的term不小于candidate当前的term，那么candidate会承认这个leader并将身份切回follower。如果心跳包中的term比自己的小，candidate会拒绝这次请求并保持选举状态。 
               - 3. 选举超时
                 - 多个follower同时成为candidate，选票可能被瓜分，导致candidate选举超时（随机选举超时时间）。此时candidate会增加term然后发起新的选举
            - leader角色转换过程
               - leader节点宕机，其他follower接收不到leader的心跳信息，首个触发超时的节点会变成candidate并开始发起选举，由于该candidate的term号大于原leader的term，因此所有follower会给它投票，candidate变为新的leader。一段时间后，原leader恢复收到了现leader的心跳包，发现了心跳中term大于自己的term，此时该节点会切换成follower跟随现leader。
      - 日志复制
        - 什么是日志复制
         - 共识算法基于状态复制机模型，所有节点从同一个状态出发，经过一系列相同log的操作后，最终达成一致的状态。所有只要我们保证集群中所有节点的log一致，那么经过apply后最终得到的状态也是一致的。
         - 所有log都交给leader处理，并由leader节点复制到其他节点。
        - 日志复制流程
         - leader为客户端提供服务，客户端的请求包含一条被状机执行的指令，leader将该指令作为日志附加到自己的日志集合中，然后向其他节点发起附加条目请求（appendentries rpc）,要求他们将该日志附加到各自本地的日志集合中。当这条日志被大多数节点复制后，leader会将该日志apply到它的本地状态机中，然后返回给客户端。
         - 日志索引（任期号，日志索引号(全局递增的)） 
         - 流程是
           - 1. s1节点当选leader，客户端向s1发起请求；
           - 2. s1新增日志(term2,index1)并向向集群中其他节点发起（appendentries rpc）
           - 3. 集群中节点收到请求，并回复s1，s1收到过半的请求后将日志apply并将日志变为已提交状态，响应客户端。
           - 4. s1后续会持续发送心包给follower，心跳包中会携带当前已提交的日志索引(term2,index1)
           - 5. 收到心跳包的follower节点将自己日志集合中的（term2,index1）日志变为已提交状态
        - 对日志一致性的保证
         - 如果不同节点日志集合中的两个条目有相同的term和index那么他们一定存储了相同的指令
         - 如果不同节点的日集合中两个条目有相同的term和index那么他们之前的所有日志条目都相同
            - 原因：leader发出的appendentries rpc中会额外携带上一条日志的(任期号，索引号)，如果follower在本找不到相同的日志会拒绝接受新的日志
        - 出现日志不一样的场景
        - 如何处理日志不一致?
          - leader节点会将自己的日志复制给followers。如果有节点拒绝接受leader发来的新日志时，说明该节点日志和leader日志不一致。此时leader会将自己的日志强制复制给该follower保证日志一致。leader会为每个follower.....
      - 安全性
         - 对选举的限制
         - 对提交的限制
      - 集群成员变更
         - 直接切换集群成员的配置产生的问题：可能出现双主
         - 如何解决--两阶段切换集群成员配置
      - 日志压缩

3. 分布式系统通信 
   - rpc
4. 一致性哈希
 