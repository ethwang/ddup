## 结果
- 简历修改之系统优化
- 简历修改之项目
- 面试
- 算法题 #78子集 #42接雨水









## 简历修改之系统优化
- 系统p99耗时在qps升高的时抖动的追查
    - goroutine频繁陷入系统调用或者有运行时间过长的goroutine阻碍了其他goroutine运行？是否go调度器有调度延迟？
        - 系统调用会使goroutine和线程阻塞，线程阻塞会导致其他goroutine排队，导致运行耗时增高。理论上go语言的sysmon会监控系统调用的P,让其他m接管它，以运行其他的goroutine。运行时间过长的goroutine也会被sysmon监控并被调度出去，给其他goroutine运行机会。 
        - 指令查看当前调度器细节 GOMAXPROCS=8 GODEBUG=schedtrace=1000,scheddetail=1 nohup ./main config conf/conf.test.toml > runoob.log 2>&1 &
        - 瞬时打印go调度器细节，发现调度器的全局goroutine队列和各个P的本地队列都没有待运行的gouroutine,说明程序还有qps提升空间，也侧面反映了压测时内存和cpu的负载不高的状态。
  
    - qps升高后锁等待问题导致耗时增加？
        - pprof-goroutine(可以看到每个goroutine运行状态)- 有sync.runtime_SemacquireMutex状态时，说明当前goroutine正在等待锁。
        - 打印程序的goroutine没有发现有长时间锁等待的情况

    - 垃圾回收问题？
        - GODEBUG=gctrace=1 go run main.go 通过指令打印出每次垃圾回收的详细状况，在这里发现一个问题是当qps升高时，垃圾回收的频次变的较高，当达到16qps时，垃圾回收的频次从500ms/次提高到接近10ms/次，是一个可疑点(但当时并没有引起足够的注意)。单次gc时间和stw时间都比较正常。


    - qps升高后的频繁gc，可能是系统分配的内存速度和容量都有所上升。所以重新审视代码，在一些方法内部打印耗时，最后定位到在查找计价配置时会将范围查找到的计价配置(品类+时间)进行clone的耗时较高(计价配置有继承，多数品类继承快车计价配置重新定价，如果直接改快车原始的计价配置，会有问题所以clone。)。使用trace工具查看clone函数的goroutine耗时达到了300ms以上，和通过在方法内部打印耗时结论一致。进一步分析发现(从trace工具上可以看到)，在gc阶段出现了大量的辅助标记。所以问题就清楚了，用户线程跑去做辅助标记了，从而影响到用户线程的执行。

    - 辅助标记：在gc情况下，由于大量的用户内存分配导致后台标记协程来不及扫描，gc标记阶段将永远不会结束，造成内存泄漏(内存无法被回收)。为了解决这个问题，golang引入了辅助标记算法，辅助标记在垃圾回收的标记阶段进行，由于用户协程被分配了超过限度的内存而不得不将其暂停并切换到辅助标记工作。

    - 发现bug: 过去是根据三元组定位一个品类，后来由于维度不够，又增加了一个维度定位品类，而代码中查找计价配置还是根据三元组这样就会查找出冗余的计价配置(后续还会过滤冗余的计价配置)进行clone。

    - 解决方式：在clone之前精确查找计价配置(通过四个维度过滤)

    - 结果：再次压测时，相同qps(16)下，p99耗时抖动相比之前下降了50%

    - 辅助标记原理:用户协程有一个可以分配的内存数量（本地+全局），超出这个数量。停止用协程序工作，并执行辅助扫描。
        https://zhuanlan.zhihu.com/p/343225555

    - 为啥不用sync.pool缓存池？


- 高峰期降低p99耗时方式-批量接口并行改造