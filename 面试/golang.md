## 内存管理
- 分配器（从**堆**中初始化相应的内存区域）  
    - 设计原理
         - 分配方法  
             - 线性分配器
             - 空闲链表分配器  
                 * **策略**   
                     * 首次适应:从链表头开始遍历,选择第一个大小大于申请内存的内存块;
                     * 循环首次适应:从上次遍历的结束位置开始遍历，选择第一个大小大雨申请内存的内存块;
                     * 最优适应:从链表头遍历整个链表，选择最合适的内存块;
                     * 隔离适应:将内存分割成多个链表，每个链表中内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；（go使用的内存分配策略与这个相似）
         - 分级分配:***核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略***  
           - 对象大小
           - 多集缓存(线程缓存，中心缓存，页堆)
               - 线程缓存属于每一个独立的线程，它能够满足线程上绝大数的内存分配需求，**因为不涉及多线程，所以也不需要使用互斥锁来保护内存，能够减少锁竞争带来的性能损耗。** 当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，再遇到32kb以上的对象时，内存分配器会选择页堆直接分配大内存
         - 虚拟内存布局
    - 内存管理组件:内存管理单元(mspan),线程缓存(mcache),中心缓存(mcentral),页堆(mheap)
        - 内存管理单元:mspan
        - 线程缓存：mcache
        - 中心缓存：mcentral
        - 页堆：mheap
    - 内存分配
      - 微对象
        - 线程缓存(mcache)中tiny字段指向了maxTinySize大小的块,如果当前块中还包含大小合适的空闲内存，运行时会通过**基地址**和**偏移量**获取并返回这块内存；
      - 小对象
          1. 确定分配对象的大小以及跨度类；
          2. 从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；
      - 大对象 
        - 运行时对于大于32kb的大对象会单独处理,不会从线程缓存和中心缓存中获取内存管理单元，直接调用runtime.mcache.allocLarge分配大片内存;
    - 总结
      1. 分级分配：核心理念是使用多级缓存将对象按照大小分类，并按照类别实施不同的分配策略 
      4. mspan是基本的内存管理单元,每一个mspan承载着一种对象大小的内存管理;
      5. mcache是线程缓存,与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有68x2个mspan（noscan:非指针类型,scan:指针类型）
      6. mcentral是中心缓存,与线程缓存不同,访问中心缓存中的内存管理单元需要使用互斥锁；
      7. mheap:堆上初始化的所有对象都由该结构体管理;该结构体包含两组重要的结构：
         (1). 全局的中心缓存列表mcentral
         (2). 管理堆区内存区域的arenas(稀疏矩阵) 
      8. 不同大小的对象分配内存的策略
        (1). 微对象(0,16B)
              将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收
        (2). 小对象[16B,32KB]
            a. 确定分配对象的大小以及跨度类;
            b. 从线程缓存，中心缓存或者堆中获取内存管理单元并从管理单元中找到空闲的内存空间
        (3). 大对象(32KB,+00)  
           -  不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用runtime.mcache.allocLarge分配大片内存

- 收集器